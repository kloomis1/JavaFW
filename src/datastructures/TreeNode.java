package datastructures;

/*
*Created by: Kyle Loomis
*Maintained by: Kyle Loomis
*Details: csci 1933 - lab 004
*/

// This is a class for Binary Search Tree nodes
public class TreeNode<E extends Comparable<E>> {

    // Member Data
    private E data;
    private TreeNode<E> leftChild;
    private TreeNode<E> rightChild;

    // Constructors
    public TreeNode(E data, TreeNode<E> leftChild, TreeNode<E> rightChild) {
        this.data = data;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }

    public TreeNode() {
        this(null, null, null);
    }

    public TreeNode(E data) {
        this(data, null, null);
    }

    public TreeNode(E data, TreeNode<E> leftChild) {
        this(data, leftChild, null);
    }

    // Getters and setters
    public E getData() {
        return this.data;
    }

    public void setData(E data) {
        this.data = data;
    }

    public TreeNode<E> getLeftChild() {
        return this.leftChild;
    }

    public void setLeftChild(TreeNode<E> leftChild) {
        this.leftChild = leftChild;
    }

    public TreeNode<E> getRightChild() {
        return this.rightChild;
    }

    public void setRightChild(TreeNode<E> rightChild) {
        this.rightChild = rightChild;
    }


    public static int size(int[] arr) {
        int size = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != -1) size++;
        }
        return size;
    }

    public static int largestLeft(int[] arr, int index) {
        if (index*2 > arr.length -1) return index -1;
        else return largestLeft(arr,index*2);
    }

    public static int smallestRight(int[] arr, int index) {
        if (index*2 > arr.length -1) return index;
        else return smallestRight(arr,index*2);
    }

    // methods below not originally included in class
    public static boolean isValid(int[] arr) {
        // calls size method to determine true number
        // of elements in array (excludes -1)
        int dynSize = size(arr) + 1;
        int levels = 1;
        int currLevel = 0;
        int root = 1;
        int child = 1;

        // determines if array containing node values
        // is a power of 2
        while (dynSize > 2) {
            dynSize /= 2;
            levels++;
        }
        if (dynSize != 2) return false;

        // compares parent to its children
        // increments children and parent index
        // inside the index brackets
        while (currLevel < levels) {
            if (!(arr[root] > arr[++child] && arr[root++] <= arr[++child]))
                return false;
            currLevel++;
        }
        // checks if largest left and smallest
        // right values are greater than/less
        // than root, respectively
        if (arr[largestLeft(arr,3)] > arr[1] || arr[smallestRight(arr,3)] < arr[1])
            return false;
        return true;
    }

    public static int levels(int[] arr) {
        int levels = 1;
        int dynSize = arr.length;

        while (dynSize >= 2) {
            dynSize /= 2;
            levels++;
        }
        return levels;
    }

    public static int[] buildTreeArray(int[] arr) {
        // int size = size(arr) + 1;
        // calls levels method to find how many levels
        // will be in the tree
        int levels = levels(arr);
        // constructs tree array with 2^levels length
        int[] treeArr = new int[(int)(Math.pow(2,levels))];
        treeArr[0] = -1;
        int idx = treeArr.length -1;

        // adds arr values to end of treeArr
        for (int j = arr.length -1; j > -1; j--) { treeArr[idx--] = arr[j]; }

        // reset idx
        idx = arr.length -1;
        // tracker for indexing treeArr
        int i = idx;
        // temp used for second loop
        int temp = idx;

        // indexes backwards through arr to
        // construct parent values in treeArr
        while (idx > 0) {
            treeArr[i--] = (arr[idx] + arr[--idx]) / 2;
            idx--;
        }

        // iterates through parent values generated by
        // former loop to finish filling in the data for
        // treeArr
        while (i > 1) {
            treeArr[i--] = (treeArr[temp] + treeArr[--temp]) / 2;
            temp--;
        }
        treeArr[1] = (treeArr[largestLeft(treeArr,3)] + treeArr[smallestRight(treeArr,3)]) / 2;

        return treeArr;
    }

    public static int treeLevels(TreeNode<Integer> root) {
        if (root == null)
            return 0;
        else {
            int l = treeLevels(root.getLeftChild());
            int r = treeLevels(root.getRightChild());
            if (l > r)
                return l + 1;
            else return r + 1;
        }
    }

    public static int[] treeToArray(TreeNode<Integer> root) {
        return treeToArrayRecursion(root,new int[(int)(Math.pow(2,treeLevels(root)))],1);
    }

    public static int[] treeToArrayRecursion(TreeNode<Integer> root, int[] arr, int index) {
        // sets 0th index to -1
        if (index == 1)
            arr[0] = -1;
        if (root == null)
            return arr;
        else {
            arr[index] = root.getData();
            treeToArrayRecursion(root.getLeftChild(),arr,index*2);
            treeToArrayRecursion(root.getRightChild(),arr,index*2 + 1);
            return arr;
        }
    }


    public static TreeNode<Integer> arrayToTree(int[] arr) {
        return arrayToTreeRecursion(arr,1,1);
    }

    public static TreeNode<Integer> arrayToTreeRecursion(int[] arr, int index, int depth) {
        if (Math.pow(2,depth) == arr.length)
            return new TreeNode<>(arr[index],null,null);
        else {
            TreeNode<Integer> tree = new TreeNode<>(arr[index]);
            tree.setLeftChild(arrayToTreeRecursion(arr, index * 2, depth + 1));
            tree.setRightChild(arrayToTreeRecursion(arr, index * 2 + 1, depth + 1));
            return tree;
        }
    }


    public static int findLargest(int[] arr, int k) {
        int value = -1;
        String directions = "";
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] <= k && arr[i] >= value) {
                value = arr[i];
            }
        }
        // calls arrayToTree to construct/assign a tree
        TreeNode<Integer> tree = arrayToTree(arr);
        if (tree.getData() != value) {
            if (value < tree.getData()) {
                tree = tree.getLeftChild();
                directions += "Left";
            }
            else {
                tree = tree.getRightChild();
                directions += "Right";
            }
        }
        else
            directions += "No movement - root";

        while (tree.getData() != value) {
            if (value < tree.getData()) {
                tree = tree.getLeftChild();
                directions += ", Left";
            }
            else {
                tree = tree.getRightChild();
                directions += ", Right";
            }
        }

        System.out.println("Directions to reach largest value: " + directions);
        return value;

    }

    public static String printTree(int[] arr) {
        String tree = "[";

        if (arr.length > 0)
            tree += String.valueOf(arr[0]);

        for (int i = 1; i < arr.length; i++) {
            tree += "," + String.valueOf(arr[i]);
        }
        tree += "]";
        return tree;
    }


    public static int countLeaves(TreeNode t) {
        if (t == null)
            return 0;
        else {
            if (t.getRightChild() == null && t.getLeftChild() == null)
                return 1;
            int r = countLeaves(t.getRightChild());
            int l = countLeaves(t.getLeftChild());
            return r + l;
        }
    }

    public static boolean lookup(int n, TreeNode t) {
        TreeNode current = t;

        while (current != null) {
            if ((int) current.getData() == n)
                return  true;
            else if (n > (int) current.getData())
                current = current.getRightChild();
            else current = current.getLeftChild();
        }

        return false;
    }

//    public static int[] inorder(TreeNode<Integer> t, int[] arr, int index, int depth) {
//        if (Math.pow(2,depth) == arr.length)
//            return arr;
//        else {
//
//
//        }
//    }


//    public static boolean lookup(int n, TreeNode t) {
//        if (t != null && (int) t.getData() == n)
//            return true;
//        else {
//            if (t != null && n > (int) t.getData())
//                return lookup(n, t.getRightChild());
//            else if (t != null && n <= (int) t.getData())
//                return lookup(n, t.getLeftChild());
//            else
//                return false;
//        }
//    }


//    public boolean lookup (int n) {
//        if (data instanceof Integer) {
//            if ((int)data == n)
//                return true;
//            else {
//                if (n > (int) data && rightChild != null)
//                    return rightChild.lookup(n);
//                else if (n <= (int) data && leftChild != null)
//                    return leftChild.lookup(n);
//                else
//                    return false;
//            }
//        }
//        else return false;
//    }


//    public static Object getRightMostData(TreeNode t) {
//        if (t != null && t.getRightChild() == null)
//            return t.getData();
//        else if (t != null)
//            return getRightMostData(t.getRightChild());
//        else return null;
//    }
//
//    public Object getRightMostData() {
//        if (getRightChild() == null)
//            return getData();
//        else
//            return rightChild.getRightMostData();
//    }
//
//    public static Object getRightMostData(TreeNode t) {
//        if (t == null)
//            return null;
//        TreeNode<E> current = t;
//        while (current.getRightChild() != null)
//            current = current.getRightChild();
//        return current.getData();
//    }
//
//    public Object getRightMostData() {
//        TreeNode<E> current = this;
//        while (current.getRightChild() != null)
//            current = current.getRightChild();
//        return current.getData();
//    }

    public static void main(String[] args) {
        int[] perfect = {-1,7,4,10,3,6,8,15};
        int[] imperfect = {-1,75,50,103,1,100,102,104};
        int[] leaves = {10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160};
        //int[] leaves = {10,20,30,40,50,60,70,80};
        //int[] leaves = {10,20,30,40};

        System.out.println("Is perfect array perfect? " + isValid(perfect));
        System.out.println("Is imperfect array perfect? " + isValid(imperfect));
        System.out.println("buildTreeArray check: " + printTree(buildTreeArray(leaves)));
        System.out.println("Largest: " + findLargest(perfect,16));

        System.out.println();

        System.out.println("Converting perfect array to tree, then back to array.");
        TreeNode<Integer> tree = arrayToTree(perfect);
        int[] arr = treeToArray(tree);
        System.out.println("treeToArray: " + printTree(arr));

        TreeNode<Integer> tree2 = arrayToTree(buildTreeArray(leaves));

        System.out.println("Count leaves: " + countLeaves(tree2));
        System.out.println("lookup method test: " + lookup(8,tree));

        TreeNode<Integer> tree3 = new TreeNode<>(8,null,null);
        tree3.setLeftChild(new TreeNode<>(5,null,null));
        tree3.setRightChild(new TreeNode<>(10,new TreeNode<>(11,null,null),null));
        System.out.println("Count leaves: " + countLeaves(tree3));

    }
}